<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title>Introduction to modelgrid</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Introduction to modelgrid</h1>



<p>modelgrid 0.9.0 is now available on CRAN. modelgrid offers a minimalistic but still very flexible framework to create, manage and train a portfolio of <code>caret</code> models.</p>
<p>This is the first official release, so below I describe the key concept behind <code>modelgrid</code> as well as the features of <code>modelgrid</code> divided into three main categories:</p>
<ul>
<li>Creating a model grid</li>
<li>Training a model grid</li>
<li>Editing a model grid</li>
</ul>
<div id="key-concept-of-model-grid" class="section level2">
<h2>Key concept of <code>model grid</code></h2>
<p>readr now has a strategy for dealing with settings that vary across languages and localities: <strong>locales</strong>. A locale, created with <code>locale()</code>, includes:</p>
<ul>
<li>The names of months and days, used when parsing dates.</li>
<li>The default time zone, used when parsing datetimes.</li>
<li>The character encoding, used when reading non-ASCII strings.</li>
<li>Default date format, used when guessing column types.</li>
<li>The decimal and grouping marks, used when reading numbers.</li>
</ul>
<p>I’ll cover the most important of these parameters below. For more details, see <code>vignette(&quot;locales&quot;)</code>.</p>
<p>To override the default US-centric locale, you pass a custom locale to <code>read_csv()</code>, <code>read_tsv()</code>, or <code>read_fwf()</code>. Rather than showing those funtions here, I’ll use the <code>parse_*()</code> functions because they work with character vectors instead of a files, but are otherwise identical.</p>
<div id="names-of-months-and-days" class="section level3">
<h3>Names of months and days</h3>
<p>The first argument to <code>locale()</code> is <code>date_names</code> which controls what values are used for month and day names. The easiest way to specify them is with a ISO 639 language code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">locale</span>(<span class="st">&quot;ko&quot;</span>) <span class="co"># Korean</span>
<span class="co">#&gt; &lt;locale&gt;</span>
<span class="co">#&gt; Numbers:  123,456.78</span>
<span class="co">#&gt; Formats:  %AD / %AT</span>
<span class="co">#&gt; Timezone: UTC</span>
<span class="co">#&gt; Encoding: UTF-8</span>
<span class="co">#&gt; &lt;date_names&gt;</span>
<span class="co">#&gt; Days:   &lt;U+C77C&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+C77C&gt;), &lt;U+C6D4&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+C6D4&gt;), &lt;U+D654&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+D654&gt;), &lt;U+C218&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+C218&gt;), &lt;U+BAA9&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+BAA9&gt;),</span>
<span class="co">#&gt;         &lt;U+AE08&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+AE08&gt;), &lt;U+D1A0&gt;&lt;U+C694&gt;&lt;U+C77C&gt; (&lt;U+D1A0&gt;)</span>
<span class="co">#&gt; Months: 1&lt;U+C6D4&gt;, 2&lt;U+C6D4&gt;, 3&lt;U+C6D4&gt;, 4&lt;U+C6D4&gt;, 5&lt;U+C6D4&gt;, 6&lt;U+C6D4&gt;, 7&lt;U+C6D4&gt;, 8&lt;U+C6D4&gt;, 9&lt;U+C6D4&gt;, 10&lt;U+C6D4&gt;, 11&lt;U+C6D4&gt;, 12&lt;U+C6D4&gt;</span>
<span class="co">#&gt; AM/PM:  &lt;U+C624&gt;&lt;U+C804&gt;/&lt;U+C624&gt;&lt;U+D6C4&gt;</span>
<span class="kw">locale</span>(<span class="st">&quot;fr&quot;</span>) <span class="co"># French</span>
<span class="co">#&gt; &lt;locale&gt;</span>
<span class="co">#&gt; Numbers:  123,456.78</span>
<span class="co">#&gt; Formats:  %AD / %AT</span>
<span class="co">#&gt; Timezone: UTC</span>
<span class="co">#&gt; Encoding: UTF-8</span>
<span class="co">#&gt; &lt;date_names&gt;</span>
<span class="co">#&gt; Days:   dimanche (dim.), lundi (lun.), mardi (mar.), mercredi (mer.),</span>
<span class="co">#&gt;         jeudi (jeu.), vendredi (ven.), samedi (sam.)</span>
<span class="co">#&gt; Months: janvier (janv.), février (févr.), mars (mars), avril (avr.), mai</span>
<span class="co">#&gt;         (mai), juin (juin), juillet (juil.), août (août),</span>
<span class="co">#&gt;         septembre (sept.), octobre (oct.), novembre (nov.),</span>
<span class="co">#&gt;         décembre (déc.)</span>
<span class="co">#&gt; AM/PM:  AM/PM</span></code></pre></div>
<p>This allows you to parse dates in other languages:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_date</span>(<span class="st">&quot;1 janvier 2015&quot;</span>, <span class="st">&quot;%d %B %Y&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="st">&quot;fr&quot;</span>))
<span class="co">#&gt; [1] &quot;2015-01-01&quot;</span>
<span class="kw">parse_date</span>(<span class="st">&quot;14 oct. 1979&quot;</span>, <span class="st">&quot;%d %b %Y&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="st">&quot;fr&quot;</span>))
<span class="co">#&gt; [1] &quot;1979-10-14&quot;</span></code></pre></div>
</div>
<div id="timezones" class="section level3">
<h3>Timezones</h3>
<p>readr assumes that times are in <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">Coordinated Universal Time</a>, aka UTC. UTC is the best timezone for data because it doesn’t have daylight savings. If your data isn’t already in UTC, you’ll need to supply a <code>tz</code> in the locale:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_datetime</span>(<span class="st">&quot;2001-10-10 20:10&quot;</span>)
<span class="co">#&gt; [1] &quot;2001-10-10 20:10:00 UTC&quot;</span>
<span class="kw">parse_datetime</span>(<span class="st">&quot;2001-10-10 20:10&quot;</span>, 
  <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">tz =</span> <span class="st">&quot;Pacific/Auckland&quot;</span>))
<span class="co">#&gt; [1] &quot;2001-10-10 20:10:00 NZDT&quot;</span>
<span class="kw">parse_datetime</span>(<span class="st">&quot;2001-10-10 20:10&quot;</span>, 
  <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">tz =</span> <span class="st">&quot;Europe/Dublin&quot;</span>))
<span class="co">#&gt; [1] &quot;2001-10-10 20:10:00 IST&quot;</span></code></pre></div>
<p>List all available times zones with <code>OlsonNames()</code>. If you’re American, note that “EST” is not Eastern Standard Time – it’s a Canadian time zone that doesn’t have DST! Instead of relying on ambiguous abbreivations, use:</p>
<ul>
<li>PST/PDT = “US/Pacific”</li>
<li>CST/CDT = “US/Central”</li>
<li>MST/MDT = “US/Mountain”</li>
<li>EST/EDT = “US/Eastern”</li>
</ul>
</div>
<div id="default-formats" class="section level3">
<h3>Default formats</h3>
<p>Locales also provide default date and time formats. The time format isn’t currently used for anything, but the date format is used when guessing column types. The default date format is <code>%Y-%m-%d</code> because that’s unambiguous:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">parse_guess</span>(<span class="st">&quot;2010-10-10&quot;</span>))
<span class="co">#&gt;  Date[1:1], format: &quot;2010-10-10&quot;</span></code></pre></div>
<p>If you’re an American, you might want you use your illogical date sytem::</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">parse_guess</span>(<span class="st">&quot;01/02/2013&quot;</span>))
<span class="co">#&gt;  chr &quot;01/02/2013&quot;</span>
<span class="kw">str</span>(<span class="kw">parse_guess</span>(<span class="st">&quot;01/02/2013&quot;</span>, 
  <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">date_format =</span> <span class="st">&quot;%d/%m/%Y&quot;</span>)))
<span class="co">#&gt;  Date[1:1], format: &quot;2013-02-01&quot;</span></code></pre></div>
</div>
<div id="character-encoding" class="section level3">
<h3>Character encoding</h3>
<p>All readr functions yield strings encoded in UTF-8. This encoding is the most likely to give good results in the widest variety of settings. By default, readr assumes that your input is also in UTF-8, which is less likely to be the case, especially when you’re working with older datasets. To parse a dataset that’s not in UTF-8, you need to a supply an <code>encoding</code>.</p>
<p>The following code creates a string encoded with latin1 (aka ISO-8859-1), and shows how it’s different from the string encoded as UTF-8, and how to parse it with readr:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;Émigré cause célèbre déjà vu.</span><span class="ch">\n</span><span class="st">&quot;</span>
y &lt;-<span class="st"> </span>stringi<span class="op">::</span><span class="kw">stri_conv</span>(x, <span class="st">&quot;UTF-8&quot;</span>, <span class="st">&quot;Latin1&quot;</span>)
<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): input data \xffffffc9</span>
<span class="co">#&gt; in current source encoding could not be converted to Unicode</span>
<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): input data \xffffffe9</span>
<span class="co">#&gt; in current source encoding could not be converted to Unicode</span>

<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): input data \xffffffe9</span>
<span class="co">#&gt; in current source encoding could not be converted to Unicode</span>
<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): input data \xffffffe8</span>
<span class="co">#&gt; in current source encoding could not be converted to Unicode</span>
<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): input data \xffffffe9</span>
<span class="co">#&gt; in current source encoding could not be converted to Unicode</span>
<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): input data \xffffffe0</span>
<span class="co">#&gt; in current source encoding could not be converted to Unicode</span>
<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): the Unicode codepoint</span>
<span class="co">#&gt; \U0000fffd cannot be converted to destination encoding</span>

<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): the Unicode codepoint</span>
<span class="co">#&gt; \U0000fffd cannot be converted to destination encoding</span>

<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): the Unicode codepoint</span>
<span class="co">#&gt; \U0000fffd cannot be converted to destination encoding</span>

<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): the Unicode codepoint</span>
<span class="co">#&gt; \U0000fffd cannot be converted to destination encoding</span>

<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): the Unicode codepoint</span>
<span class="co">#&gt; \U0000fffd cannot be converted to destination encoding</span>

<span class="co">#&gt; Warning in stringi::stri_conv(x, &quot;UTF-8&quot;, &quot;Latin1&quot;): the Unicode codepoint</span>
<span class="co">#&gt; \U0000fffd cannot be converted to destination encoding</span>

<span class="co"># These strings look like they're identical:</span>
x
<span class="co">#&gt; [1] &quot;Émigré cause célèbre déjà vu.\n&quot;</span>
y
<span class="co">#&gt; [1] &quot;\032migr\032 cause c\032l\032bre d\032j\032 vu.\n&quot;</span>
<span class="kw">identical</span>(x, y)
<span class="co">#&gt; [1] FALSE</span>

<span class="co"># But they have different encodings:</span>
<span class="kw">Encoding</span>(x)
<span class="co">#&gt; [1] &quot;unknown&quot;</span>
<span class="kw">Encoding</span>(y)
<span class="co">#&gt; [1] &quot;unknown&quot;</span>

<span class="co"># That means while they print the same, their raw (binary)</span>
<span class="co"># representation is actually rather different:</span>
<span class="kw">charToRaw</span>(x)
<span class="co">#&gt;  [1] c9 6d 69 67 72 e9 20 63 61 75 73 65 20 63 e9 6c e8 62 72 65 20 64 e9</span>
<span class="co">#&gt; [24] 6a e0 20 76 75 2e 0a</span>
<span class="kw">charToRaw</span>(y)
<span class="co">#&gt;  [1] 1a 6d 69 67 72 1a 20 63 61 75 73 65 20 63 1a 6c 1a 62 72 65 20 64 1a</span>
<span class="co">#&gt; [24] 6a 1a 20 76 75 2e 0a</span>

<span class="co"># readr expects strings to be encoded as UTF-8. If they're</span>
<span class="co"># not, you'll get weird characters</span>
<span class="kw">parse_character</span>(x)
<span class="co">#&gt; [1] &quot;&lt;c9&gt;migr&lt;e9&gt; cause c&lt;e9&gt;l&lt;e8&gt;bre d&lt;e9&gt;j&lt;e0&gt; vu.\n&quot;</span>
<span class="kw">parse_character</span>(y)
<span class="co">#&gt; [1] &quot;\032migr\032 cause c\032l\032bre d\032j\032 vu.\n&quot;</span>

<span class="co"># If you know the encoding, supply it:</span>
<span class="kw">parse_character</span>(y, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">encoding =</span> <span class="st">&quot;latin1&quot;</span>))
<span class="co">#&gt; [1] &quot;\032migr\032 cause c\032l\032bre d\032j\032 vu.\n&quot;</span></code></pre></div>
<p>If you don’t know what encoding the file uses, try <code>guess_encoding()</code>. It’s not 100% perfect (as it’s fundamentally a heuristic), but should at least get you pointed in the right direction:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">guess_encoding</span>(y)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;   encoding confidence</span>
<span class="co">#&gt;   &lt;chr&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt; 1 ASCII             1</span>

<span class="co"># Note that the first guess produces a valid string, </span>
<span class="co"># but isn't correct:</span>
<span class="kw">parse_character</span>(y, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">encoding =</span> <span class="st">&quot;ISO-8859-2&quot;</span>))
<span class="co">#&gt; [1] &quot;\032migr\032 cause c\032l\032bre d\032j\032 vu.\n&quot;</span>
<span class="co"># But ISO-8859-1 is another name for latin1</span>
<span class="kw">parse_character</span>(y, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">encoding =</span> <span class="st">&quot;ISO-8859-1&quot;</span>))
<span class="co">#&gt; [1] &quot;\032migr\032 cause c\032l\032bre d\032j\032 vu.\n&quot;</span></code></pre></div>
</div>
<div id="numbers" class="section level3">
<h3>Numbers</h3>
<p>Some countries use the decimal point, while others use the decimal comma. The <code>decimal_mark</code> option controls which readr uses when parsing doubles:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_double</span>(<span class="st">&quot;1,23&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">decimal_mark =</span> <span class="st">&quot;,&quot;</span>))
<span class="co">#&gt; [1] 1.23</span></code></pre></div>
<p>The <code>big_mark</code> option describes which character is used to space groups of digits. Do you write <code>1,000,000</code>, <code>1.000.000</code>, <code>1 000 000</code>, or <code>1'000'000</code>? Specifying the grouping mark allows <code>parse_number()</code> to parse large number as they’re commonly written:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;1,234.56&quot;</span>)
<span class="co">#&gt; [1] 1234.56</span>

<span class="co"># dplyr is smart enough to guess that if you're using , for </span>
<span class="co"># decimals then you're probably using . for grouping:</span>
<span class="kw">parse_number</span>(<span class="st">&quot;1.234,56&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">decimal_mark =</span> <span class="st">&quot;,&quot;</span>))
<span class="co">#&gt; [1] 1234.56</span></code></pre></div>
</div>
</div>
<div id="column-parsing-improvements" class="section level2">
<h2>Column parsing improvements</h2>
<p>One of the most useful parts of readr are the column parsers: the tools that turns character input into usefully typed data frame columns. This process is now described more fully in a new vignette: <code>vignette(&quot;column-types&quot;)</code>.</p>
<p>By default, column types are guessed by looking at the data. I’ve made a number of tweaks to make it more likely that your code will load correctly the first time:</p>
<ul>
<li><p>readr now looks at the first 1000 rows (instead of just the first 100) when guessing column types: this only takes a fraction more time, but should hopefully yield better guesses for more inputs.</p></li>
<li><p><code>col_date()</code> and <code>col_datetime()</code> no longer recognise partial dates like 19, 1900, 1900-01. These triggered many false positives and after re-reading the ISO8601 spec, I believe they actually refer to periods of time, so should not be parsed into a specific instant.</p></li>
<li><p><code>col_integer()</code> no longer recognises values started with zeros (e.g. 0001) as these are often used as identifiers.</p></li>
<li><p><code>col_number()</code> will automatically recognise numbers containing the grouping mark (see below for more details).</p></li>
</ul>
<p>But you can override these defaults with the <code>col_types()</code> argument. In this version, <code>col_types</code> gains some much needed flexibility:</p>
<ul>
<li><p>New <code>cols()</code> function takes of assembling the list of column types, and with its <code>.default</code> argument, allows you to control the default column type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;x,y</span><span class="ch">\n</span><span class="st">1,2&quot;</span>, <span class="dt">col_types =</span> <span class="kw">cols</span>(<span class="dt">.default =</span> <span class="st">&quot;c&quot;</span>))
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;   x     y    </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1 1     2</span></code></pre></div>
<p>You can refer to parsers with their full name (e.g. <code>col_character()</code>) or their one letter abbreviation (e.g. <code>c</code>). The default value of <code>.default</code> is “?”: guess the type of column from the data.</p></li>
<li><p><code>cols_only()</code> allows you to load only the specified columns:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span><span class="ch">\n</span><span class="st">1,2,3&quot;</span>, <span class="dt">col_types =</span> <span class="kw">cols_only</span>(<span class="st">&quot;b&quot;</span> =<span class="st"> &quot;?&quot;</span>))
<span class="co">#&gt; Warning in read_tokens_(data, tokenizer, col_specs, col_names, locale_, :</span>
<span class="co">#&gt; length of NULL cannot be changed</span>

<span class="co">#&gt; Warning in read_tokens_(data, tokenizer, col_specs, col_names, locale_, :</span>
<span class="co">#&gt; length of NULL cannot be changed</span>

<span class="co">#&gt; Warning in read_tokens_(data, tokenizer, col_specs, col_names, locale_, :</span>
<span class="co">#&gt; length of NULL cannot be changed</span>

<span class="co">#&gt; Warning in read_tokens_(data, tokenizer, col_specs, col_names, locale_, :</span>
<span class="co">#&gt; length of NULL cannot be changed</span>
<span class="co">#&gt; # A tibble: 1 x 1</span>
<span class="co">#&gt;       b</span>
<span class="co">#&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1     2</span></code></pre></div></li>
</ul>
<p>Many of the individual parsers have also been improved:</p>
<ul>
<li><p><code>col_integer()</code> and <code>col_double()</code> no longer silently ignore trailing characters after the number.</p></li>
<li><p>New <code>col_number()</code>/<code>parse_number()</code> replace the old <code>col_numeric()</code>/ <code>parse_numeric()</code>. This parser is less flexible, so it’s less likely to silently ignored bad input. It’s designed specifically to read currencies and percentages. It only reads the first number from a string, ignoring the grouping mark defined by the locale:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;1,234,566&quot;</span>)
<span class="co">#&gt; [1] 1234566</span>
<span class="kw">parse_number</span>(<span class="st">&quot;$1,234&quot;</span>)
<span class="co">#&gt; [1] 1234</span>
<span class="kw">parse_number</span>(<span class="st">&quot;27%&quot;</span>)
<span class="co">#&gt; [1] 27</span></code></pre></div></li>
<li><p>New <code>parse_time()</code> and <code>col_time()</code> allow you to parse times. They have an optional <code>format</code> argument, that uses the same components as <code>parse_datetime()</code>. If <code>format</code> is omitted, they use a flexible parser that looks for hours, then an optional colon, then minutes, then an optional colon, then optional seconds, then optional am/pm.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_time</span>(<span class="kw">c</span>(<span class="st">&quot;1:45 PM&quot;</span>, <span class="st">&quot;1345&quot;</span>, <span class="st">&quot;13:45:00&quot;</span>))
<span class="co">#&gt; Warning: 1 parsing failure.</span>
<span class="co">#&gt; row # A tibble: 1 x 4 col     row   col expected     actual expected   &lt;int&gt; &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;  actual 1     2    NA &quot;time like &quot; 1345</span>
<span class="co">#&gt; 13:45:00</span>
<span class="co">#&gt;       NA</span>
<span class="co">#&gt; 13:45:00</span></code></pre></div>
<p><code>parse_time()</code> returns the number of seconds since midnight as an integer with class “time”. readr includes a basic print method.</p></li>
<li><p><code>parse_date()</code>/<code>col_date()</code> and <code>parse_datetime()</code>/<code>col_datetime()</code> gain two new format strings: “%+” skips one or more non-digits, and <code>%p</code> reads in AM/PM (and am/pm).</p></li>
</ul>
</div>
<div id="file-parsing-improvements" class="section level2">
<h2>File parsing improvements</h2>
<p><code>read_csv()</code>, <code>read_tsv()</code>, and <code>read_delim()</code> gain extra arguments that allow you to parse more files:</p>
<ul>
<li><p>Multiple NA values can be specified by passing a character vector to <code>na</code>. The default has been changed to <code>na = c(&quot;&quot;, &quot;NA&quot;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b</span><span class="ch">\n</span><span class="st">.,NA</span><span class="ch">\n</span><span class="st">1,3&quot;</span>, <span class="dt">na =</span> <span class="kw">c</span>(<span class="st">&quot;.&quot;</span>, <span class="st">&quot;NA&quot;</span>))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;       a     b</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1    NA    NA</span>
<span class="co">#&gt; 2     1     3</span></code></pre></div></li>
<li><p>New <code>comment</code> argument allows you to ignore all text after a string:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(
<span class="st">&quot;#This is a comment</span>
<span class="st">#This is another comment</span>
<span class="st">a,b</span>
<span class="st">1,10</span>
<span class="st">2,20&quot;</span>, <span class="dt">comment =</span> <span class="st">&quot;#&quot;</span>)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;       a     b</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1    10</span>
<span class="co">#&gt; 2     2    20</span></code></pre></div></li>
<li><p><code>trim_ws</code> argument controls whether leading and trailing whitespace is removed. It defaults to <code>TRUE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b</span><span class="ch">\n</span><span class="st">     1,     2&quot;</span>)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;       a     b</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1     2</span>
<span class="kw">read_csv</span>(<span class="st">&quot;a,b</span><span class="ch">\n</span><span class="st">     1,     2&quot;</span>, <span class="dt">trim_ws =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;   a        b       </span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;chr&gt;   </span>
<span class="co">#&gt; 1 &quot;     1&quot; &quot;     2&quot;</span></code></pre></div></li>
</ul>
<p>Specifying the wrong number of column names, or having rows with an unexpected number of columns, now gives a warning, rather than an error:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span><span class="ch">\n</span><span class="st">1,2</span><span class="ch">\n</span><span class="st">1,2,3,4&quot;</span>)
<span class="co">#&gt; Warning: 2 parsing failures.</span>
<span class="co">#&gt; row # A tibble: 2 x 5 col     row col   expected  actual    file         expected   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;        actual 1     1 &lt;NA&gt;  3 columns 2 columns literal data file 2     2 &lt;NA&gt;  3 columns 4 columns literal data</span>
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;       a     b     c</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1     2    NA</span>
<span class="co">#&gt; 2     1     2     3</span></code></pre></div>
<p>Note that the warning message now also shows you the first five problems. I hope this will often allow you to iterate immediately, rather than having to look at the full <code>problems()</code>.</p>
</div>
<div id="writers" class="section level2">
<h2>Writers</h2>
<p>Despite the name, readr also provides some tools for writing data frames to disk. In this version there are three output functions:</p>
<ul>
<li><p><code>write_csv()</code> and <code>write_tsv()</code> write tab and comma delimted files, and <code>write_delim()</code> writes with user specified delimiter.</p></li>
<li><p><code>write_rds()</code> and <code>read_rds()</code> wrap around <code>readRDS()</code> and <code>saveRDS()</code>, defaulting to no compression, because you’re usually more interested in saving time (expensive) than disk space (cheap).</p></li>
</ul>
<p>All these functions invisibly return their output so you can use them as part of a pipeline:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_df <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">some_manipulation</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">write_csv</span>(<span class="st">&quot;interim-a.csv&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">some_more_manipulation</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">write_csv</span>(<span class="st">&quot;interim-b.csv&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">even_more_manipulation</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">write_csv</span>(<span class="st">&quot;final.csv&quot;</span>)</code></pre></div>
<p>You can now control how missing values are written with the <code>na</code> argument, and the quoting algorithm has been further refined to only add quotes when needed: when the string contains a quote, the delimiter, a new line or the same text as missing value.</p>
<p>Output for doubles now uses the same precision as R, and POSIXt vectors are saved in a ISO8601 compatible format.</p>
<p>For testing, you can use <code>format_csv()</code>, <code>format_tsv()</code>, and <code>format_delim()</code> to write csv to a string:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">4</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">format_csv</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">cat</span>()
<span class="co">#&gt; mpg,cyl,disp,hp,drat,wt,qsec,vs,am,gear,carb</span>
<span class="co">#&gt; 21,6,160,110,3.9,2.62,16.46,0,1,4,4</span>
<span class="co">#&gt; 21,6,160,110,3.9,2.875,17.02,0,1,4,4</span>
<span class="co">#&gt; 22.8,4,108,93,3.85,2.32,18.61,1,1,4,1</span>
<span class="co">#&gt; 21.4,6,258,110,3.08,3.215,19.44,1,0,3,1</span></code></pre></div>
<p>This is particularly useful for generating <a href="https://github.com/jennybc/reprex">reprexes</a>.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
